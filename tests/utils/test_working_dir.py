from pathlib import Path
from unittest.mock import patch

from Babylon.utils.working_dir import WorkingDir


def test_working_init():
    """Testing working dir"""
    WorkingDir(Path("tests/resources/workingdir/"))


@patch("shutil.copytree")
def test_copy_template(copytree: callable):
    """Testing working dir"""
    workdir = WorkingDir(Path("anypath"))
    workdir.copy_template()
    copytree.assert_called()


@patch("shutil.copytree")
def test_working_compare_zip_fail(_):
    """Testing working dir"""
    workdir = WorkingDir(Path("tests/resources/a.zip"))
    assert not workdir.compare_to_template()


def test_working_requires_file():
    """Testing working dir"""
    workdir = WorkingDir(Path("tests/resources/workingdir/"))
    assert workdir.requires_file("API/workingdir.yaml")
    assert not workdir.requires_file("API/notfound.json")


def test_working_get_file():
    """Testing working dir"""
    workpath = "tests/resources/workingdir/"
    workdir = WorkingDir(Path(workpath))
    filepath = "API/workingdir.yaml"
    assert workdir.get_file(filepath) == Path(workpath) / Path(filepath)


def test_working_str():
    """Testing working dir"""
    workdir = WorkingDir(Path("tests/resources/workingdir/"))
    workstr = str(workdir)
    assert "API/" in workstr
    assert "is_zip: False" in workstr


def test_working_zip():
    """Testing working dir"""
    workdir = WorkingDir(Path("tests/resources/workingdir.zip"))
    workstr = str(workdir)
    assert "API/workingdir.yaml" in workstr
    assert "is_zip: True" in workstr


def test_working_create_zip():
    """Testing working dir"""
    workdir = WorkingDir(Path("tests/resources/workingdir/"))
    with patch("zipfile.ZipFile") as file:
        workdir.create_zip("anything.zip")
        file.assert_called()


def test_working_create_zip_failed():
    """Testing working dir"""
    workdir = WorkingDir(Path("willNotBeUsed"))
    with patch("zipfile.ZipFile") as file:
        workdir.create_zip("anything")
        file.assert_not_called()


def test_working_create_zip_failed_2():
    """Testing working dir"""
    workdir = WorkingDir(Path("tests/resources/workingdir"))
    with patch("zipfile.ZipFile") as file:
        workdir.create_zip("tests/resources/workingdir.zip")
        file.assert_not_called()


def test_working_create_zip_failed_3():
    """Testing working dir"""
    workdir = WorkingDir(Path("tests/resources/test"))
    response = workdir.create_zip("tests/resources/workingdir.zip")
    assert not response


def test_working_create_zip_copy():
    """Testing working dir"""
    workdir = WorkingDir(Path("tests/resources/workingdir.zip"))
    with patch("shutil.copy") as file:
        workdir.create_zip("anything.zip")
        file.assert_called()


# There is no test to ensure encryption is constant because the algorithm is time based
# Runs at different times results on different encryption


def test_decrypt_content():
    """Testing that content decryption works"""
    original_data = b"This is a string of data ta should be back after encryption"
    # encoding key was generated by encryption a 32 char long byte string using base64
    encoding_key = b"U3ltZXRyaWNhbEVuY3JpcHRpb25LZXlJc0FMZW4zMkI="
    # encoded data was generated by calling Fernet.encrypt using the encoding key and the original data
    encoded_data = (b"gAAAAABj42B0aQKz0izKkBaCYBJiCrMufDAuE5Hy85i70m1stpi0iO4hHttvBsToUj_hLqe81bosRwNhyAV82pbbrp-"
                    b"b3OAEYGp_JDieGtf60p00uZ-uuJZ2gTDT27iqsPclVdhp46_ZG6oQFX3JXtBLSGcqEr0h2A==")
    decoded_data = WorkingDir.decrypt_content(encoding_key, encoded_data)
    assert original_data == decoded_data
